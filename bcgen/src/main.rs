mod decl;
mod gen;

#[allow(dead_code)]
mod support;

use std::fs;
use std::path::Path;
use std::process::Command;

fn bytecode() -> decl::Bytecode {
    decl::def! {
        op nop()
        op mov(src: Reg, dst: Reg)
        op load_cst(src: Cst, dst: Reg)
        op load_unit(dst: Reg)
        op load_smi(val: Smi, dst: Reg)
        op load_true(dst: Reg)
        op load_false(dst: Reg)
    }
    decl::def! {
        template bool<val>
        "load_{val}" (dst: Reg)
    }
    decl::def! {
        with bool
        [true]
        [false]
    }
    decl::def! {
        template arithmetic<name, ty>
        "{name}_{ty}" (lhs: Reg, rhs: Reg, dst: Reg)
    }
    decl::def! {
        with arithmetic
        [add, int]
        [add, num]
        [sub, int]
        [sub, num]
        [mul, int]
        [mul, num]
        [div, int]
        [div, num]
        [rem, int]
        [rem, num]
    }
    decl::def! {
        op call0_direct(fnid: Fnid, ret: Reg)
        op call_direct(fnid: Fnid, ret: Reg)
        op call0_indirect(fnr: Reg, ret: Reg)
        op call_indirect(fnr: Reg, ret: Reg)
    }
    decl::def! {
        op ret()
        op retv(src: Reg)
    }
    decl::def! {
        op stop()
    }

    decl::def! {
        type Reg: u8 = "r{0}"
        type Cst: u16 = "c{0}"
        type Cap: u16 = "^{0}"
        type Mvar: u16 = "m{0}"
        type Fnid: u16 = "{0}"
        type Smi: i8 = "{0}"
    }

    decl::finish()
}

fn main() -> anyhow::Result<()> {
    let code = gen::run(&bytecode());

    let now = chrono::Utc::now().to_rfc2822();
    let text = format!(
        "/*\
    \nThis file was generated by bcgen on {now}.\
    \nYou can regenerate it by running `cargo run -p bcgen -- src/code/op.x src/code/op.rs`.\
    \n*/"
    );
    let code = format!("{text}\n{code}");

    let output_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("src/code/op.rs");

    fs::write(&output_path, code).expect("failed to write output file");

    let result = Command::new("cargo")
        .args(["fmt", "--"])
        .arg(&output_path)
        .spawn()
        .unwrap()
        .wait()
        .unwrap();
    if !result.success() {
        anyhow::bail!("failed to run `cargo fmt` on the generated file");
    }

    Ok(())
}
