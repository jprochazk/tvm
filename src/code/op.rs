/*
This file was generated by bcgen on Fri, 5 Jan 2024 12:38:46 +0000.
You can regenerate it by running `cargo run -p bcgen -- src/code/op.x src/code/op.rs`.
*/
//! Instruction encoding, decoding, disassembly, and dispatch.
#![allow(dead_code, unused_variables)]

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Op {
    Nop = 0,
    Mov = 1,
    LoadCst = 2,
    LoadUnit = 3,
    LoadSmi = 4,
    LoadTrue = 5,
    LoadFalse = 6,
    Ret = 7,
    Stop = 8,
}

impl Op {
    const MIN: u8 = Op::Nop as u8;
    const MAX: u8 = Op::Stop as u8;
}

impl Encode for Op {
    #[inline]
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_u8(self as u8)
    }
}
impl Decode for Op {
    #[inline(always)]
    unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
        let v = buf.decode_u8_unchecked();
        debug_assert!(v <= Op::MAX);
        unsafe { core::mem::transmute(v) }
    }
}

pub mod operands {
    #![doc = " Operand encoding and decoding"]
    use super::*;
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct Nop {}
    impl Decode for Nop {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {}
        }
    }
    impl Encode for Nop {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::Nop.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct Mov {
        pub src: Reg,
        pub dst: Reg,
    }
    impl Decode for Mov {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {
                src: Decode::decode_unchecked(buf),
                dst: Decode::decode_unchecked(buf),
            }
        }
    }
    impl Encode for Mov {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::Mov.encode(enc);
            self.src.encode(enc);
            self.dst.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct LoadCst {
        pub src: Cst,
        pub dst: Reg,
    }
    impl Decode for LoadCst {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {
                src: Decode::decode_unchecked(buf),
                dst: Decode::decode_unchecked(buf),
            }
        }
    }
    impl Encode for LoadCst {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::LoadCst.encode(enc);
            self.src.encode(enc);
            self.dst.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct LoadUnit {
        pub dst: Reg,
    }
    impl Decode for LoadUnit {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {
                dst: Decode::decode_unchecked(buf),
            }
        }
    }
    impl Encode for LoadUnit {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::LoadUnit.encode(enc);
            self.dst.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct LoadSmi {
        pub val: Smi,
        pub dst: Reg,
    }
    impl Decode for LoadSmi {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {
                val: Decode::decode_unchecked(buf),
                dst: Decode::decode_unchecked(buf),
            }
        }
    }
    impl Encode for LoadSmi {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::LoadSmi.encode(enc);
            self.val.encode(enc);
            self.dst.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct LoadTrue {
        pub dst: Reg,
    }
    impl Decode for LoadTrue {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {
                dst: Decode::decode_unchecked(buf),
            }
        }
    }
    impl Encode for LoadTrue {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::LoadTrue.encode(enc);
            self.dst.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct LoadFalse {
        pub dst: Reg,
    }
    impl Decode for LoadFalse {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {
                dst: Decode::decode_unchecked(buf),
            }
        }
    }
    impl Encode for LoadFalse {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::LoadFalse.encode(enc);
            self.dst.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct Ret {
        pub src: Reg,
    }
    impl Decode for Ret {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {
                src: Decode::decode_unchecked(buf),
            }
        }
    }
    impl Encode for Ret {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::Ret.encode(enc);
            self.src.encode(enc);
        }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub struct Stop {}
    impl Decode for Stop {
        #[inline(always)]
        unsafe fn decode_unchecked(buf: &mut impl Decoder) -> Self {
            Self {}
        }
    }
    impl Encode for Stop {
        #[inline]
        fn encode<E>(self, enc: &mut E)
        where
            E: ?Sized + Encoder,
        {
            Op::Stop.encode(enc);
        }
    }
}

pub mod asm {
    #![doc = " Bytecode assembler"]
    use super::*;
    #[inline]
    pub fn nop() -> impl Encode {
        operands::Nop {}
    }
    #[inline]
    pub fn mov(src: Reg, dst: Reg) -> impl Encode {
        operands::Mov { src, dst }
    }
    #[inline]
    pub fn load_cst(src: Cst, dst: Reg) -> impl Encode {
        operands::LoadCst { src, dst }
    }
    #[inline]
    pub fn load_unit(dst: Reg) -> impl Encode {
        operands::LoadUnit { dst }
    }
    #[inline]
    pub fn load_smi(val: Smi, dst: Reg) -> impl Encode {
        operands::LoadSmi { val, dst }
    }
    #[inline]
    pub fn load_true(dst: Reg) -> impl Encode {
        operands::LoadTrue { dst }
    }
    #[inline]
    pub fn load_false(dst: Reg) -> impl Encode {
        operands::LoadFalse { dst }
    }
    #[inline]
    pub fn ret(src: Reg) -> impl Encode {
        operands::Ret { src }
    }
    #[inline]
    pub fn stop() -> impl Encode {
        operands::Stop {}
    }
}

pub mod symbolic {
    #![doc = " Symbolic representation of instructions"]
    pub use super::operands::*;
    use super::*;
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum Instruction {
        Nop(Nop),
        Mov(Mov),
        LoadCst(LoadCst),
        LoadUnit(LoadUnit),
        LoadSmi(LoadSmi),
        LoadTrue(LoadTrue),
        LoadFalse(LoadFalse),
        Ret(Ret),
        Stop(Stop),
    }
    impl Decode for Instruction {
        unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
            match Op::decode_unchecked(dec) {
                Op::Nop => Instruction::Nop(Nop::decode_unchecked(dec)),
                Op::Mov => Instruction::Mov(Mov::decode_unchecked(dec)),
                Op::LoadCst => Instruction::LoadCst(LoadCst::decode_unchecked(dec)),
                Op::LoadUnit => Instruction::LoadUnit(LoadUnit::decode_unchecked(dec)),
                Op::LoadSmi => Instruction::LoadSmi(LoadSmi::decode_unchecked(dec)),
                Op::LoadTrue => Instruction::LoadTrue(LoadTrue::decode_unchecked(dec)),
                Op::LoadFalse => Instruction::LoadFalse(LoadFalse::decode_unchecked(dec)),
                Op::Ret => Instruction::Ret(Ret::decode_unchecked(dec)),
                Op::Stop => Instruction::Stop(Stop::decode_unchecked(dec)),
            }
        }
    }
    impl std::fmt::Display for Instruction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Instruction::Nop(Nop {}) => write!(f, "nop "),
                Instruction::Mov(Mov { src, dst }) => write!(f, "mov {src}, {dst}"),
                Instruction::LoadCst(LoadCst { src, dst }) => write!(f, "load_cst {src}, {dst}"),
                Instruction::LoadUnit(LoadUnit { dst }) => write!(f, "load_unit {dst}"),
                Instruction::LoadSmi(LoadSmi { val, dst }) => write!(f, "load_smi {val}, {dst}"),
                Instruction::LoadTrue(LoadTrue { dst }) => write!(f, "load_true {dst}"),
                Instruction::LoadFalse(LoadFalse { dst }) => write!(f, "load_false {dst}"),
                Instruction::Ret(Ret { src }) => write!(f, "ret {src}"),
                Instruction::Stop(Stop {}) => write!(f, "stop "),
            }
        }
    }
}

pub mod dispatch {
    #![doc = " Dispatch loop"]
    use operands::*;

    use super::*;
    type Code = [u8];
    type Ip = usize;
    pub trait Handler {
        type Result<T>;
        fn op_nop(&self) -> Self::Result<()>;
        fn op_mov(&self, src: Reg, dst: Reg) -> Self::Result<()>;
        fn op_load_cst(&self, src: Cst, dst: Reg) -> Self::Result<()>;
        fn op_load_unit(&self, dst: Reg) -> Self::Result<()>;
        fn op_load_smi(&self, val: Smi, dst: Reg) -> Self::Result<()>;
        fn op_load_true(&self, dst: Reg) -> Self::Result<()>;
        fn op_load_false(&self, dst: Reg) -> Self::Result<()>;
        fn op_ret(&self, src: Reg) -> Self::Result<()>;
        fn op_stop(&self) -> Self::Result<()>;
    }
    #[doc = " Dispatch a single instruction"]
    #[doc = " # Safety"]
    #[doc = " - `&code[*ip..]` must contain a valid bytecode instruction"]
    #[inline(always)]
    pub unsafe fn dispatch<H: Handler>(h: &H, ip: &mut Ip, code: &Code) -> H::Result<()> {
        let inst = &mut &code[*ip..];
        match Op::decode_unchecked(inst) {
            Op::Nop => {
                let Nop {} = Nop::decode_unchecked(inst);
                h.op_nop()
            }
            Op::Mov => {
                let Mov { src, dst } = Mov::decode_unchecked(inst);
                h.op_mov(src, dst)
            }
            Op::LoadCst => {
                let LoadCst { src, dst } = LoadCst::decode_unchecked(inst);
                h.op_load_cst(src, dst)
            }
            Op::LoadUnit => {
                let LoadUnit { dst } = LoadUnit::decode_unchecked(inst);
                h.op_load_unit(dst)
            }
            Op::LoadSmi => {
                let LoadSmi { val, dst } = LoadSmi::decode_unchecked(inst);
                h.op_load_smi(val, dst)
            }
            Op::LoadTrue => {
                let LoadTrue { dst } = LoadTrue::decode_unchecked(inst);
                h.op_load_true(dst)
            }
            Op::LoadFalse => {
                let LoadFalse { dst } = LoadFalse::decode_unchecked(inst);
                h.op_load_false(dst)
            }
            Op::Ret => {
                let Ret { src } = Ret::decode_unchecked(inst);
                h.op_ret(src)
            }
            Op::Stop => {
                let Stop {} = Stop::decode_unchecked(inst);
                h.op_stop()
            }
        }
    }
}

pub trait Encoder {
    fn encode_slice(&mut self, v: &[u8]);

    #[inline]
    fn encode_u8(&mut self, v: u8) {
        self.encode_slice(&v.to_le_bytes());
    }

    #[inline]
    fn encode_u16(&mut self, v: u16) {
        self.encode_slice(&v.to_le_bytes());
    }

    #[inline]
    fn encode_u32(&mut self, v: u32) {
        self.encode_slice(&v.to_le_bytes());
    }

    #[inline]
    fn encode_u64(&mut self, v: u64) {
        self.encode_slice(&v.to_le_bytes());
    }

    fn encode_i8(&mut self, v: i8) {
        self.encode_slice(&v.to_le_bytes());
    }

    #[inline]
    fn encode_i16(&mut self, v: i16) {
        self.encode_slice(&v.to_le_bytes());
    }

    #[inline]
    fn encode_i32(&mut self, v: i32) {
        self.encode_slice(&v.to_le_bytes());
    }

    #[inline]
    fn encode_i64(&mut self, v: i64) {
        self.encode_slice(&v.to_le_bytes());
    }
}

pub trait Encode {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder;
}

pub trait Decoder {
    /// # Safety
    /// `self` must have enough bytes left to decode a `u8`.
    unsafe fn decode_u8_unchecked(&mut self) -> u8;

    /// # Safety
    /// `self` must have enough bytes left to decode a `u16`.
    unsafe fn decode_u16_unchecked(&mut self) -> u16;

    /// # Safety
    /// `self` must have enough bytes left to decode a `u32`.
    unsafe fn decode_u32_unchecked(&mut self) -> u32;

    /// # Safety
    /// `self` must have enough bytes left to decode a `u64`.
    unsafe fn decode_u64_unchecked(&mut self) -> u64;

    /// # Safety
    /// `self` must have enough bytes left to decode an `i8`.
    unsafe fn decode_i8_unchecked(&mut self) -> i8;

    /// # Safety
    /// `self` must have enough bytes left to decode an `i16`.
    unsafe fn decode_i16_unchecked(&mut self) -> i16;

    /// # Safety
    /// `self` must have enough bytes left to decode an `i32`.
    unsafe fn decode_i32_unchecked(&mut self) -> i32;

    /// # Safety
    /// `self` must have enough bytes left to decode an `i64`.
    unsafe fn decode_i64_unchecked(&mut self) -> i64;
}

pub trait Decode: Sized {
    /// # Safety
    /// `dec` must have enough bytes left to decode `Self`.
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self;
}

impl Encoder for Vec<u8> {
    #[inline]
    fn encode_slice(&mut self, v: &[u8]) {
        self.extend_from_slice(v);
    }
}

#[inline(always)]
unsafe fn unsafe_advance(slice: &mut &[u8], n: usize) {
    use std::ops::Sub;
    use std::slice::from_raw_parts;

    debug_assert!(n <= slice.len());
    let (ptr, len) = ((*slice).as_ptr(), (*slice).len());
    let remainder = from_raw_parts(ptr.add(n), len.sub(n));
    *slice = remainder;
}

impl Decoder for &'_ [u8] {
    #[inline(always)]
    unsafe fn decode_u8_unchecked(&mut self) -> u8 {
        debug_assert!(self.len() >= std::mem::size_of::<u8>());
        let v = u8::from_le_bytes([*self.get_unchecked(0)]);
        unsafe_advance(self, std::mem::size_of::<u8>());
        v
    }

    #[inline(always)]
    unsafe fn decode_u16_unchecked(&mut self) -> u16 {
        debug_assert!(self.len() >= std::mem::size_of::<u16>());
        let v = u16::from_le_bytes([*self.get_unchecked(0), *self.get_unchecked(1)]);
        unsafe_advance(self, std::mem::size_of::<u16>());
        v
    }

    #[inline(always)]
    unsafe fn decode_u32_unchecked(&mut self) -> u32 {
        debug_assert!(self.len() >= std::mem::size_of::<u32>());
        let v = u32::from_le_bytes([
            *self.get_unchecked(0),
            *self.get_unchecked(1),
            *self.get_unchecked(2),
            *self.get_unchecked(3),
        ]);
        unsafe_advance(self, std::mem::size_of::<u32>());
        v
    }

    #[inline(always)]
    unsafe fn decode_u64_unchecked(&mut self) -> u64 {
        debug_assert!(self.len() >= std::mem::size_of::<u64>());
        let v = u64::from_le_bytes([
            *self.get_unchecked(0),
            *self.get_unchecked(1),
            *self.get_unchecked(2),
            *self.get_unchecked(3),
            *self.get_unchecked(4),
            *self.get_unchecked(5),
            *self.get_unchecked(6),
            *self.get_unchecked(7),
        ]);
        unsafe_advance(self, std::mem::size_of::<u64>());
        v
    }

    #[inline(always)]
    unsafe fn decode_i8_unchecked(&mut self) -> i8 {
        debug_assert!(self.len() >= std::mem::size_of::<i8>());
        let v = i8::from_le_bytes([*self.get_unchecked(0)]);
        unsafe_advance(self, std::mem::size_of::<i8>());
        v
    }

    #[inline(always)]
    unsafe fn decode_i16_unchecked(&mut self) -> i16 {
        debug_assert!(self.len() >= std::mem::size_of::<i16>());
        let v = i16::from_le_bytes([*self.get_unchecked(0), *self.get_unchecked(1)]);
        unsafe_advance(self, std::mem::size_of::<i16>());
        v
    }

    #[inline(always)]
    unsafe fn decode_i32_unchecked(&mut self) -> i32 {
        debug_assert!(self.len() >= std::mem::size_of::<i32>());
        let v = i32::from_le_bytes([
            *self.get_unchecked(0),
            *self.get_unchecked(1),
            *self.get_unchecked(2),
            *self.get_unchecked(3),
        ]);
        unsafe_advance(self, std::mem::size_of::<i32>());
        v
    }

    #[inline(always)]
    unsafe fn decode_i64_unchecked(&mut self) -> i64 {
        debug_assert!(self.len() >= std::mem::size_of::<i64>());
        let v = i64::from_le_bytes([
            *self.get_unchecked(0),
            *self.get_unchecked(1),
            *self.get_unchecked(2),
            *self.get_unchecked(3),
            *self.get_unchecked(4),
            *self.get_unchecked(5),
            *self.get_unchecked(6),
            *self.get_unchecked(7),
        ]);
        unsafe_advance(self, std::mem::size_of::<i64>());
        v
    }
}

impl Decoder for std::io::Cursor<&'_ [u8]> {
    #[inline]
    unsafe fn decode_u8_unchecked(&mut self) -> u8 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_u8_unchecked();
        self.set_position(pos + std::mem::size_of::<u8>() as u64);
        v
    }

    #[inline]
    unsafe fn decode_u16_unchecked(&mut self) -> u16 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_u16_unchecked();
        self.set_position(pos + std::mem::size_of::<u16>() as u64);
        v
    }

    #[inline]
    unsafe fn decode_u32_unchecked(&mut self) -> u32 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_u32_unchecked();
        self.set_position(pos + std::mem::size_of::<u32>() as u64);
        v
    }

    #[inline]
    unsafe fn decode_u64_unchecked(&mut self) -> u64 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_u64_unchecked();
        self.set_position(pos + std::mem::size_of::<u64>() as u64);
        v
    }

    #[inline]
    unsafe fn decode_i8_unchecked(&mut self) -> i8 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_i8_unchecked();
        self.set_position(pos + std::mem::size_of::<i8>() as u64);
        v
    }

    #[inline]
    unsafe fn decode_i16_unchecked(&mut self) -> i16 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_i16_unchecked();
        self.set_position(pos + std::mem::size_of::<i16>() as u64);
        v
    }

    #[inline]
    unsafe fn decode_i32_unchecked(&mut self) -> i32 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_i32_unchecked();
        self.set_position(pos + std::mem::size_of::<i32>() as u64);
        v
    }

    #[inline]
    unsafe fn decode_i64_unchecked(&mut self) -> i64 {
        let pos = self.position();
        let slice = &mut &*self.get_ref().get_unchecked(pos as usize..);
        let v = slice.decode_i64_unchecked();
        self.set_position(pos + std::mem::size_of::<i64>() as u64);
        v
    }
}

macro_rules! operand_type {
    (
        pub struct $name:ident($inner:ty) = $fmt:literal;
    ) => {
        #[must_use = concat!("unused ", stringify!($name))]
        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub struct $name($inner);

        impl $name {
            #[inline]
            pub fn new(v: $inner) -> Self {
                Self(v)
            }

            #[inline]
            pub fn try_new<T>(v: T) -> Option<Self>
            where
                $inner: TryFrom<T>,
            {
                <$inner>::try_from(v).map($name).ok()
            }

            #[inline]
            pub fn get(self) -> $inner {
                self.0
            }

            #[inline]
            pub fn to_index(self) -> usize {
                self.0 as usize
            }
        }

        impl Encode for $name {
            #[inline]
            fn encode<E>(self, enc: &mut E)
            where
                E: ?Sized + Encoder,
            {
                self.0.encode(enc)
            }
        }

        impl Decode for $name {
            #[inline(always)]
            unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
                Self(<$inner as Decode>::decode_unchecked(dec))
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, $fmt, self.0)
            }
        }
    };
}

impl Encode for u8 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_u8(self)
    }
}

impl Encode for u16 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_u16(self)
    }
}

impl Encode for u32 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_u32(self)
    }
}

impl Encode for u64 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_u64(self)
    }
}

impl Encode for i8 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_i8(self)
    }
}

impl Encode for i16 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_i16(self)
    }
}

impl Encode for i32 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_i32(self)
    }
}

impl Encode for i64 {
    fn encode<E>(self, enc: &mut E)
    where
        E: ?Sized + Encoder,
    {
        enc.encode_i64(self)
    }
}

impl Decode for u8 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_u8_unchecked()
    }
}

impl Decode for u16 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_u16_unchecked()
    }
}

impl Decode for u32 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_u32_unchecked()
    }
}

impl Decode for u64 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_u64_unchecked()
    }
}

impl Decode for i8 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_i8_unchecked()
    }
}

impl Decode for i16 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_i16_unchecked()
    }
}

impl Decode for i32 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_i32_unchecked()
    }
}

impl Decode for i64 {
    #[inline(always)]
    unsafe fn decode_unchecked(dec: &mut impl Decoder) -> Self {
        dec.decode_i64_unchecked()
    }
}

operand_type! {
    pub struct Reg(u8) = "r{0}";
}

operand_type! {
    pub struct Cst(u16) = "c{0}";
}

operand_type! {
    pub struct Capture(u16) = "^{0}";
}

operand_type! {
    pub struct Mvar(u16) = "m{0}";
}

operand_type! {
    pub struct FnId(u16) = "{0}";
}

operand_type! {
    pub struct Smi(i8) = "{0}";
}

impl Smi {
    pub fn is_smi(v: i64) -> bool {
        (i8::MIN as i64..=i8::MAX as i64).contains(&v)
    }
}
