/*
This file was generated by bcgen on Sat, 24 Feb 2024 14:48:57 +0000.
You can regenerate it by running `cargo gen`.
*/
//! Instruction encoding, decoding, disassembly, and dispatch.
#![allow(dead_code, unused_variables)]

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Op {
    Nop,
    Mov { src: Reg, dst: Reg },
    Load_Const { src: Cst, dst: Reg },
    Load_Unit { dst: Reg },
    Load_Fn { id: Fnid, dst: Reg },
    Load_Smi { val: Smi, dst: Reg },
    Load_Bool { val: bool, dst: Reg },
    Jump { offset: Rel },
    Jump_Const { offset: Cst },
    JumpIfFalse { cond: Reg, offset: Rel },
    JumpIfFalse_Const { cond: Reg, offset: Cst },
    Add_I64 { lhs: Reg, rhs: Reg, dst: Reg },
    Add_F64 { lhs: Reg, rhs: Reg, dst: Reg },
    Sub_I64 { lhs: Reg, rhs: Reg, dst: Reg },
    Sub_F64 { lhs: Reg, rhs: Reg, dst: Reg },
    Mul_I64 { lhs: Reg, rhs: Reg, dst: Reg },
    Mul_F64 { lhs: Reg, rhs: Reg, dst: Reg },
    Div_I64 { lhs: Reg, rhs: Reg, dst: Reg },
    Div_F64 { lhs: Reg, rhs: Reg, dst: Reg },
    Rem_I64 { lhs: Reg, rhs: Reg, dst: Reg },
    Rem_F64 { lhs: Reg, rhs: Reg, dst: Reg },
    Call_Id { callee: Fnid, ret: Reg },
    Call_Reg { callee: Reg },
    Ret,
    Ret_V { src: Reg },
    Stop = 255,
}

pub mod asm {
    #![doc = " Bytecode assembler"]
    use super::*;

    #[inline]
    pub fn nop() -> Op {
        Op::Nop {}
    }

    #[inline]
    pub fn mov(src: Reg, dst: Reg) -> Op {
        Op::Mov { src, dst }
    }

    #[inline]
    pub fn load_cst(src: Cst, dst: Reg) -> Op {
        Op::Load_Const { src, dst }
    }

    #[inline]
    pub fn load_unit(dst: Reg) -> Op {
        Op::Load_Unit { dst }
    }

    #[inline]
    pub fn load_fn(id: Fnid, dst: Reg) -> Op {
        Op::Load_Fn { id, dst }
    }

    #[inline]
    pub fn load_smi(val: Smi, dst: Reg) -> Op {
        Op::Load_Smi { val, dst }
    }

    #[inline]
    pub fn load_bool(val: bool, dst: Reg) -> Op {
        Op::Load_Bool { val, dst }
    }

    #[inline]
    pub fn jmp(offset: Rel) -> Op {
        Op::Jump { offset }
    }

    #[inline]
    pub fn jmp_c(offset: Cst) -> Op {
        Op::Jump_Const { offset }
    }

    #[inline]
    pub fn jmpf(cond: Reg, offset: Rel) -> Op {
        Op::JumpIfFalse { cond, offset }
    }

    #[inline]
    pub fn jmpf_c(cond: Reg, offset: Cst) -> Op {
        Op::JumpIfFalse_Const { cond, offset }
    }

    pub enum Type {
        I64,
        F64,
    }
    pub use Type::*;

    #[inline]
    pub fn add(ty: Type, lhs: Reg, rhs: Reg, dst: Reg) -> Op {
        match ty {
            I64 => Op::Add_I64 { lhs, rhs, dst },
            F64 => Op::Add_F64 { lhs, rhs, dst },
        }
    }

    #[inline]
    pub fn sub(ty: Type, lhs: Reg, rhs: Reg, dst: Reg) -> Op {
        match ty {
            I64 => Op::Sub_I64 { lhs, rhs, dst },
            F64 => Op::Sub_F64 { lhs, rhs, dst },
        }
    }

    #[inline]
    pub fn mul(ty: Type, lhs: Reg, rhs: Reg, dst: Reg) -> Op {
        match ty {
            I64 => Op::Mul_I64 { lhs, rhs, dst },
            F64 => Op::Mul_F64 { lhs, rhs, dst },
        }
    }

    #[inline]
    pub fn div(ty: Type, lhs: Reg, rhs: Reg, dst: Reg) -> Op {
        match ty {
            I64 => Op::Div_I64 { lhs, rhs, dst },
            F64 => Op::Div_F64 { lhs, rhs, dst },
        }
    }

    #[inline]
    pub fn rem(ty: Type, lhs: Reg, rhs: Reg, dst: Reg) -> Op {
        match ty {
            I64 => Op::Rem_I64 { lhs, rhs, dst },
            F64 => Op::Rem_F64 { lhs, rhs, dst },
        }
    }

    #[inline]
    pub fn call_id(callee: Fnid, ret: Reg) -> Op {
        Op::Call_Id { callee, ret }
    }

    #[inline]
    pub fn call_reg(callee: Reg) -> Op {
        Op::Call_Reg { callee }
    }

    #[inline]
    pub fn ret() -> Op {
        Op::Ret {}
    }

    #[inline]
    pub fn retv(src: Reg) -> Op {
        Op::Ret_V { src }
    }

    #[inline]
    pub fn stop() -> Op {
        Op::Stop {}
    }
}

#[must_use = "unused Reg"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Reg(pub u8);
impl Reg {
    #[inline]
    pub fn try_new<T>(v: T) -> Option<Self>
    where
        u8: TryFrom<T>,
    {
        <u8>::try_from(v).map(Reg).ok()
    }
    #[inline]
    pub fn get(self) -> u8 {
        self.0
    }
    #[inline]
    pub fn to_index(self) -> usize {
        self.0 as usize
    }
}

impl std::fmt::Display for Reg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "r{0}", self.0)
    }
}

#[must_use = "unused Cst"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Cst(pub u16);

impl Cst {
    #[inline]
    pub fn try_new<T>(v: T) -> Option<Self>
    where
        u16: TryFrom<T>,
    {
        <u16>::try_from(v).map(Cst).ok()
    }
    #[inline]
    pub fn get(self) -> u16 {
        self.0
    }
    #[inline]
    pub fn to_index(self) -> usize {
        self.0 as usize
    }
}

impl std::fmt::Display for Cst {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{0}]", self.0)
    }
}

#[must_use = "unused Mvar"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Mvar(pub u16);

impl Mvar {
    #[inline]
    pub fn try_new<T>(v: T) -> Option<Self>
    where
        u16: TryFrom<T>,
    {
        <u16>::try_from(v).map(Mvar).ok()
    }
    #[inline]
    pub fn get(self) -> u16 {
        self.0
    }
    #[inline]
    pub fn to_index(self) -> usize {
        self.0 as usize
    }
}

impl std::fmt::Display for Mvar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "m{0}", self.0)
    }
}

#[must_use = "unused Fnid"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Fnid(pub u16);

impl Fnid {
    #[inline]
    pub fn try_new<T>(v: T) -> Option<Self>
    where
        u16: TryFrom<T>,
    {
        <u16>::try_from(v).map(Fnid).ok()
    }
    #[inline]
    pub fn get(self) -> u16 {
        self.0
    }
    #[inline]
    pub fn to_index(self) -> usize {
        self.0 as usize
    }
}

impl std::fmt::Display for Fnid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "f{0}", self.0)
    }
}

#[must_use = "unused Smi"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Smi(pub i8);

impl Smi {
    #[inline]
    pub fn try_new<T>(v: T) -> Option<Self>
    where
        i8: TryFrom<T>,
    {
        <i8>::try_from(v).map(Smi).ok()
    }
    #[inline]
    pub fn get(self) -> i8 {
        self.0
    }
    #[inline]
    pub fn to_index(self) -> usize {
        self.0 as usize
    }
}

impl std::fmt::Display for Smi {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{0}", self.0)
    }
}

#[must_use = "unused Rel"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Rel(pub i16);

impl Rel {
    #[inline]
    pub fn try_new<T>(v: T) -> Option<Self>
    where
        i16: TryFrom<T>,
    {
        <i16>::try_from(v).map(Rel).ok()
    }
    #[inline]
    pub fn get(self) -> i16 {
        self.0
    }
    #[inline]
    pub fn to_index(self) -> usize {
        self.0 as usize
    }
}

impl std::fmt::Display for Rel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.0.signum() {
            0 => write!(f, "0"),
            -1 => write!(f, "-{}", self.0),
            1 => write!(f, "+{}", self.0),
            _ => unreachable!(),
        }
    }
}

impl std::fmt::Display for Op {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Op::Nop => write!(f, "nop "),
            Op::Mov { src, dst } => write!(f, "mov {src}, {dst}"),
            Op::Load_Const { src, dst } => write!(f, "cst {src}, {dst}"),
            Op::Load_Unit { dst } => write!(f, "unit {dst}"),
            Op::Load_Fn { id, dst } => write!(f, "fn {id}, {dst}"),
            Op::Load_Smi { val, dst } => write!(f, "smi {val}, {dst}"),
            Op::Load_Bool { val, dst } => write!(f, "bool {val}, {dst}"),
            Op::Jump { offset } => write!(f, "jmp {offset}"),
            Op::Jump_Const { offset } => write!(f, "jmp {offset}"),
            Op::JumpIfFalse { cond, offset } => write!(f, "jmpf {cond}, {offset}"),
            Op::JumpIfFalse_Const { cond, offset } => write!(f, "jmpf {cond}, {offset}"),
            Op::Add_I64 { lhs, rhs, dst } => {
                write!(f, "add <i64> {lhs}, {rhs}, {dst}")
            }
            Op::Add_F64 { lhs, rhs, dst } => {
                write!(f, "add <f64> {lhs}, {rhs}, {dst}")
            }
            Op::Sub_I64 { lhs, rhs, dst } => {
                write!(f, "sub <i64> {lhs}, {rhs}, {dst}")
            }
            Op::Sub_F64 { lhs, rhs, dst } => {
                write!(f, "sub <f64> {lhs}, {rhs}, {dst}")
            }
            Op::Mul_I64 { lhs, rhs, dst } => {
                write!(f, "mul <i64> {lhs}, {rhs}, {dst}")
            }
            Op::Mul_F64 { lhs, rhs, dst } => {
                write!(f, "mul <f64> {lhs}, {rhs}, {dst}")
            }
            Op::Div_I64 { lhs, rhs, dst } => {
                write!(f, "div <i64> {lhs}, {rhs}, {dst}")
            }
            Op::Div_F64 { lhs, rhs, dst } => {
                write!(f, "div <f64> {lhs}, {rhs}, {dst}")
            }
            Op::Rem_I64 { lhs, rhs, dst } => {
                write!(f, "rem <i64> {lhs}, {rhs}, {dst}")
            }
            Op::Rem_F64 { lhs, rhs, dst } => {
                write!(f, "rem <f64> {lhs}, {rhs}, {dst}")
            }
            Op::Call_Id { callee, ret } => {
                write!(f, "call {callee}, {ret}")
            }
            Op::Call_Reg { callee } => {
                write!(f, "call {callee}")
            }
            Op::Ret {} => write!(f, "ret "),
            Op::Ret_V { src } => write!(f, "retv {src}"),
            Op::Stop => write!(f, "stop "),
        }
    }
}
